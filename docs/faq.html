<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Frequently Asked Questions | Google Cloud APIs </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Frequently Asked Questions | Google Cloud APIs ">
    <meta name="generator" content="docfx 2.24.0.0">
    
    <link rel="shortcut icon" href="favicon.ico">
    <link rel="stylesheet" href="styles/docfx.vendor.css">
    <link rel="stylesheet" href="styles/docfx.css">
    <link rel="stylesheet" href="styles/main.css">
    <meta property="docfx:navrel" content="toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="index.html">
                <img id="logo" class="svg" src="logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="article row grid">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="frequently-asked-questions">Frequently Asked Questions</h1>

<h2 id="how-can-i-use-non-default-credentials-for-grpc-based-apis">How can I use non-default credentials for gRPC-based APIs?</h2>
<p>The generated classes for gRPC-based APIs (such as
<a href="Google.Cloud.PubSub.V1/api/Google.Cloud.PubSub.V1.PublisherClient.html">PublisherClient</a>)
have <code>Create</code> overloads of this form:</p>
<pre><code class="lang-csharp">public static PublisherClient Create(ServiceEndpoint endpoint = null, PublisherSettings settings = null)

public static PublisherClient Create(Channel channel, PublisherSettings settings = null)
</code></pre><p>(Equivalent asynchronous overloads exist as well.)</p>
<p>The first of these uses the default credentials to create a channel
which is shared by all instances created in the same way, and
optionally shut down using the <code>ShutDownDefaultChannelsAsync</code> method.</p>
<p>The second of these never creates a new channel, and the caller is
responsible for explicit clean-up if required. See <a href="guides/cleanup.html">&quot;Unmanaged
resource clean-up&quot;</a> for more details on situations where
this is important.</p>
<p>To create a client with specific credentials, you have to create the
channel yourself, as the client doesn&#39;t expose the channel it uses.
Creating a channel is simple, once you have a <code>ChannelCredentials</code>
object, typically created using the <code>ToChannelCredentials</code> extension
method. For example, to create a channel for a specific user:</p>
<pre><code class="lang-csharp">// Make the ToChannelCredentials extension method available
using Grpc.Auth;

...

// Obtain a user&#39;s credentials in an appropriate manner for your
// application. See
// https://developers.google.com/api-client-library/dotnet/guide/aaa_oauth
UserCredential userCredential = ...;
ChannelCredentials channelCredentials = userCredential.ToChannelCredentials();
Channel channel = new Channel(PublisherClient.DefaultEndpoint, channelCredentials);
PublisherClient client = PublisherClient.Create(channel);
// Now use client, and clean up channel if and when you need to.
</code></pre><p>Note that if you construct a <code>GoogleCredential</code> (e.g. with
<code>GoogleCredential.FromFile</code>) you should apply the scopes required by
the API using the <code>GoogleCredential.CreateScoped</code> method and the <code>DefaultScopes</code>
property from the API you&#39;re using. For example:</p>
<pre><code>GoogleCredential credential = GoogleCredential
    .FromFile(&quot;auth.json&quot;)
    .CreateScoped(PublisherClient.DefaultScopes);
ChannelCredentials channelCredentials = credential.ToChannelCredentials();
...
</code></pre><p>It&#39;s also possible to specify credentials for an
individual RPC call. For example, you can create a channel using the
default application credentials, then specify a <code>CallCredentials</code> in
the <code>CallSettings</code> passed to a single method call. The
<code>ToCallCredentials()</code> method can be used to create a
<code>CallCredentials</code>:</p>
<pre><code class="lang-csharp">// Make the ToCallCredentials extension method available
using Grpc.Auth;

...

// Obtain a user&#39;s credentials in an appropriate manner for your
// application. See
// https://developers.google.com/api-client-library/dotnet/guide/aaa_oauth
UserCredential userCredential = ...;
CallCredentials callCredentials = userCredential.ToCallCredentials();

// Use the default application credentials for the channel.
PublisherClient client = PublisherClient.Create();
client.Publish(/* regular method arguments */,
    CallSettings.FromCallCredentials(callCredentials));
</code></pre><p>This approach means you don&#39;t need to worry about channel clean-up.</p>
<p>We expect to make all of this easier over time, at least for common
scenarios where you don&#39;t perform any channel shutdown. We also hope
to remove the requirement to specify the scopes when creating
credentials manually.</p>
<h2 id="how-can-i-trace-grpc-issues">How can I trace gRPC issues?</h2>
<p>For libraries that use gRPC, it can be very useful to hook into the
gRPC logging framework. There are two aspects to this:</p>
<ul>
<li>Setting environment variables</li>
<li>Directing logs</li>
</ul>
<p>The environment variables affecting gRPC are <a href="https://github.com/grpc/grpc/blob/master/doc/environment_variables.md">listed in the gRPC
repository</a>.
The important ones for diagnostics are <code>GRPC_TRACE</code> and
<code>GRPC_VERBOSITY</code>. For example, you might want to start off with
<code>GRPC_TRACE=all</code> and <code>GRPC_VERBOSITY=DEBUG</code> which will dump a <em>lot</em>
of information, then tweak them to reduce this to only useful
data... or start with one kind of tracing (e.g.
<code>GRPC_TRACE=call_error</code>) and add more as required.</p>
<p>By default, the gRPC logs will not be displayed anywhere. The
simplest way of seeing gRPC logs in many cases will be to send them
to the console:</p>
<pre><code class="lang-csharp">using Grpc.Core;
using Grpc.Core.Logging;
...
// Call this before you do any gRPC work
GrpcEnvironment.SetLogger(new ConsoleLogger());
</code></pre><p>Other <code>ILogger</code> implementations are available, or you can implement
it yourself to integrate with other systems - see the
<a href="https://github.com/grpc/grpc/tree/master/src/csharp/Grpc.Core/Logging">Grpc.Core.Logging</a>
namespace for details.</p>
<h2 id="how-can-i-trace-requests-and-responses-in-rest-based-apis">How can I trace requests and responses in REST-based APIs?</h2>
<p>For libraries that use HTTP1.1 and REST, it can be useful to perfom request and response
logging. There are two aspects to this:</p>
<ul>
<li>Registering a global logger</li>
<li>Configuring the events to log in a specific service</li>
</ul>
<p>The underlying service is available via the <code>Service</code> property in each <code>XyzClient</code> class. Within
that service, you need to configure the <code>HttpClient</code>&#39;s message handler. As a complete example,
here&#39;s a call to the Translation API, listing all the available languages, and logging the request
headers and the response body:</p>
<pre><code class="lang-cs">// Required using directives:
// using static Google.Apis.Http.ConfigurableMessageHandler;
// using Google.Apis.Logging;
// using Google.Cloud.Translation.V2;

// Register a verbose console logger
ApplicationContext.RegisterLogger(new ConsoleLogger(LogLevel.All));

// Create a translation client
TranslationClient client = TranslationClient.Create();

// Configure which events the message handler will log.
client.Service.HttpClient.MessageHandler.LogEvents =
    LogEventType.RequestHeaders | LogEventType.ResponseBody;

// Make the request
client.ListLanguages();
</code></pre><p>To log <em>all</em> events from the message handler, you can set the <code>LogEvents</code> property to
<code>~LogEventType.None</code>.</p>
<h2 id="how-can-i-use-emulators">How can I use emulators?</h2>
<p>Some APIs (such as Datastore and PubSub) provide emulators in the
<a href="https://cloud.google.com/sdk/">Cloud SDK</a>. Client libraries in some
other languages automatically use emulators if specific environment
variables are set, but the Google Cloud Libraries for .NET do not do
this. (We are hoping to work with a more ambient emulator manager
solution which does not require environment variables, and is
therefore more amenable to IDEs such as Visual Studio.)</p>
<p>However, it is quite simple to manually create the appropriate
client for gRPC-based APIs, by first creating a channel and then
passing that to the static <code>Create</code> method of the relevant client
class. Note that in current emulator implementations, the channel
credentials must be set to <code>ChannelCredentials.Insecure</code>.</p>
<p>Example for PubSub:</p>
<pre><code class="lang-cs">// For example, &quot;localhost:8615&quot;
string emulatorHostAndPort = Environment.GetEnvironmentVariable(&quot;PUBSUB_EMULATOR_HOST&quot;);

Channel channel = new Channel(emulatorHostAndPort, ChannelCredentials.Insecure);
PublisherClient client = PublisherClient.Create(channel);
client.CreateTopic(new TopicName(&quot;project&quot;, &quot;topic&quot;));
foreach (var topic in client.ListTopics(new ProjectName(&quot;project&quot;)))
{
    Console.WriteLine(topic.Name);
}
</code></pre><h2 id="why-arent-the-grpc-native-libraries-being-found">Why aren&#39;t the gRPC native libraries being found?</h2>
<p>The native libraries that gRPC relies on are present in
<a href="https://www.nuget.org/packages/Grpc.Core/">Grpc.Core</a>,
and the NuGet package has targets to copy them to appropriate output
directories. However, due to the way NuGet dependencies are
generated with .NET Core, you may find that with transitive
dependencies, the targets aren&#39;t executed.</p>
<p>We&#39;ve set up our client libraries (e.g. <code>Google.Cloud.Datastore.V1</code>)
so that if you directly depend on any of them, everything should
work - but if your application only has transitive dependencies, you
could run into errors like this:</p>
<pre><code class="lang-text">Unhandled Exception: System.IO.FileNotFoundException:
  Error loading native library. Not found in any of the possible locations: [...]
   at Grpc.Core.Internal.UnmanagedLibrary.FirstValidLibraryPath(String[] libraryPathAlternatives)
   at Grpc.Core.Internal.UnmanagedLibrary..ctor(String[] libraryPathAlternatives)
   at Grpc.Core.Internal.NativeExtension.Load()
   at Grpc.Core.Internal.NativeExtension..ctor()
   at Grpc.Core.Internal.NativeExtension.Get()
   at Grpc.Core.GrpcEnvironment.GrpcNativeInit()
   at Grpc.Core.GrpcEnvironment..ctor()
   ...
</code></pre><p>In that case, the simplest fix is to add a direct dependency to
<code>Grpc.Core</code> from your application, which will ensure that the
native libraries are copied appropriately.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
             
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="styles/docfx.js"></script>
    <script type="text/javascript" src="styles/main.js"></script>
  </body>
</html>
