<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Frequently Asked Questions | Google Cloud APIs </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Frequently Asked Questions | Google Cloud APIs ">
    <meta name="generator" content="docfx 2.39.1.0">
    
    <link rel="shortcut icon" href="favicon.ico">
    <link rel="stylesheet" href="styles/docfx.vendor.css">
    <link rel="stylesheet" href="styles/docfx.css">
    <link rel="stylesheet" href="styles/main.css">
    <meta property="docfx:navrel" content="toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="index.html">
                <img id="logo" class="svg" src="logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="article row grid">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="frequently-asked-questions">Frequently Asked Questions</h1>

<h2 id="how-can-i-use-non-default-credentials-for-grpc-based-apis">How can I use non-default credentials for gRPC-based APIs?</h2>
<p>One option - and an option that has worked for these APIs since the
start - is to create your own channel based on gRPC channel
credentials, and pass that to the <code>Create</code> method.</p>
<p>However, the libraries now implement a <em>client builder</em> pattern to make
life considerably simpler when you wish to specify different
credentials or a different API endpoint.</p>
<p>The general pattern is to create a builder (using the same name as
the client type, with a suffix of <code>Builder</code>), populate any
propreties to override some aspect of the behavior, and then call
<code>Build</code>. For example:</p>
<pre><code class="lang-csharp">SpeechClient client = new SpeechClientBuilder
{
    // Populate properties here
}.Build();
</code></pre><p>In terms of credentials, there are four (mutually-exclusive)
properties you can use to specify credentials:</p>
<ul>
<li><code>ChannelCredentials</code>: the gRPC credentials to use</li>
<li><code>CredentialsPath</code>: the path to a JSON file containing service account credentials</li>
<li><code>JsonCredentials</code>: a string (in JSON format) containing service account credentials</li>
<li><code>TokenAccessMethod</code>: a delegate used to provide access tokens</li>
</ul>
<p>The final property is a delegate to avoid exposing a dependency on
<code>Google.Apis.Auth</code> in the API surface, but the intention of it is to
allow you to use any <code>ICredential</code> (e.g. a <code>GoogleCredential</code> or a
<code>UserCredential</code>) via a method group conversion. For example, to
create a <code>SpeechClient</code> with a <code>UserCredential</code>, you would write
code like this:</p>
<pre><code class="lang-csharp">UserCredential credential = ...;
SpeechClient client = new SpeechClientBuilder
{
    TokenAccessMethod = credential.GetAccessTokenForRequestAsync
}.Build();
</code></pre><h2 id="how-can-i-trace-grpc-issues">How can I trace gRPC issues?</h2>
<p>For libraries that use gRPC, it can be very useful to hook into the
gRPC logging framework. There are two aspects to this:</p>
<ul>
<li>Setting environment variables</li>
<li>Directing logs</li>
</ul>
<p>The environment variables affecting gRPC are <a href="https://github.com/grpc/grpc/blob/master/doc/environment_variables.md">listed in the gRPC
repository</a>.
The important ones for diagnostics are <code>GRPC_TRACE</code> and
<code>GRPC_VERBOSITY</code>. For example, you might want to start off with
<code>GRPC_TRACE=all</code> and <code>GRPC_VERBOSITY=DEBUG</code> which will dump a <em>lot</em>
of information, then tweak them to reduce this to only useful
data... or start with one kind of tracing (e.g.
<code>GRPC_TRACE=call_error</code>) and add more as required.</p>
<p>By default, the gRPC logs will not be displayed anywhere. The
simplest way of seeing gRPC logs in many cases will be to send them
to the console:</p>
<pre><code class="lang-csharp">using Grpc.Core;
using Grpc.Core.Logging;
...
// Call this before you do any gRPC work
GrpcEnvironment.SetLogger(new ConsoleLogger());
</code></pre><p>Other <code>ILogger</code> implementations are available, or you can implement
it yourself to integrate with other systems - see the
<a href="https://github.com/grpc/grpc/tree/master/src/csharp/Grpc.Core/Logging">Grpc.Core.Logging</a>
namespace for details.</p>
<h2 id="how-can-i-trace-requests-and-responses-in-rest-based-apis">How can I trace requests and responses in REST-based APIs?</h2>
<p>For libraries that use HTTP1.1 and REST, it can be useful to perfom request and response
logging. There are two aspects to this:</p>
<ul>
<li>Registering a global logger</li>
<li>Configuring the events to log in a specific service</li>
</ul>
<p>The underlying service is available via the <code>Service</code> property in each <code>XyzClient</code> class. Within
that service, you need to configure the <code>HttpClient</code>&#39;s message handler. As a complete example,
here&#39;s a call to the Translation API, listing all the available languages, and logging the request
headers and the response body:</p>
<pre><code class="lang-cs">// Required using directives:
// using static Google.Apis.Http.ConfigurableMessageHandler;
// using Google.Apis.Logging;
// using Google.Cloud.Translation.V2;

// Register a verbose console logger
ApplicationContext.RegisterLogger(new ConsoleLogger(LogLevel.All));

// Create a translation client
TranslationClient client = TranslationClient.Create();

// Configure which events the message handler will log.
client.Service.HttpClient.MessageHandler.LogEvents =
    LogEventType.RequestHeaders | LogEventType.ResponseBody;

// Make the request
client.ListLanguages();
</code></pre><p>To log <em>all</em> events from the message handler, you can set the <code>LogEvents</code> property to
<code>~LogEventType.None</code>.</p>
<h2 id="how-can-i-use-emulators">How can I use emulators?</h2>
<p>Some APIs (such as Datastore and PubSub) provide emulators in the
<a href="https://cloud.google.com/sdk/">Cloud SDK</a>. Client libraries in some
other languages automatically use emulators if specific environment
variables are set, but the Google Cloud Libraries for .NET do not do
this in GA libraries.</p>
<p>However, it is quite simple to manually create the appropriate
client for gRPC-based APIs, by first creating a channel and then
passing that to the static <code>Create</code> method of the relevant client
class. Note that in current emulator implementations, the channel
credentials must be set to <code>ChannelCredentials.Insecure</code>.</p>
<p>Example for PubSub:</p>
<pre><code class="lang-cs">// For example, &quot;localhost:8615&quot;
string emulatorHostAndPort = Environment.GetEnvironmentVariable(&quot;PUBSUB_EMULATOR_HOST&quot;);

Channel channel = new Channel(emulatorHostAndPort, ChannelCredentials.Insecure);
PublisherServiceApiClient client = PublisherServiceApiClient.Create(channel);
client.CreateTopic(new TopicName(&quot;project&quot;, &quot;topic&quot;));
foreach (var topic in client.ListTopics(new ProjectName(&quot;project&quot;)))
{
    Console.WriteLine(topic.Name);
}
</code></pre><h3 id="beta-support-for-datastore-emulator-detection">Beta support for Datastore emulator detection</h3>
<p>From 2.2.0-beta02, the Datastore library has support for detecting
and using the emulator. See the <a href="Google.Cloud.Datastore.V1/">Datastore API documentation</a>
for more details and an example.</p>
<h2 id="why-arent-the-grpc-native-libraries-being-found">Why aren&#39;t the gRPC native libraries being found?</h2>
<p>The native libraries that gRPC relies on are present in
<a href="https://www.nuget.org/packages/Grpc.Core/">Grpc.Core</a>,
and the NuGet package has targets to copy them to appropriate output
directories. However, due to the way NuGet dependencies are
generated with .NET Core, you may find that with transitive
dependencies, the targets aren&#39;t executed.</p>
<p>We&#39;ve set up our client libraries (e.g. <code>Google.Cloud.Datastore.V1</code>)
so that if you directly depend on any of them, everything should
work - but if your application only has transitive dependencies, you
could run into errors like this:</p>
<pre><code class="lang-text">Unhandled Exception: System.IO.FileNotFoundException:
  Error loading native library. Not found in any of the possible locations: [...]
   at Grpc.Core.Internal.UnmanagedLibrary.FirstValidLibraryPath(String[] libraryPathAlternatives)
   at Grpc.Core.Internal.UnmanagedLibrary..ctor(String[] libraryPathAlternatives)
   at Grpc.Core.Internal.NativeExtension.Load()
   at Grpc.Core.Internal.NativeExtension..ctor()
   at Grpc.Core.Internal.NativeExtension.Get()
   at Grpc.Core.GrpcEnvironment.GrpcNativeInit()
   at Grpc.Core.GrpcEnvironment..ctor()
   ...
</code></pre><p>In that case, the simplest fix is to add a direct dependency to
<code>Grpc.Core</code> from your application, which will ensure that the
native libraries are copied appropriately.</p>
<h2 id="how-can-i-modify-repeated-fields-and-maps-in-protobuf-messages">How can I modify repeated fields and maps in protobuf messages?</h2>
<p>The generated C# code for protobuf messages makes simple properties
read/write, but repeated fields and map fields are read-only. That
doesn&#39;t stop you from populating them, though: it just means you
can&#39;t change the property to refer to a <em>different</em> list or map.</p>
<p>Typically you&#39;ll populate this using a <em>collection initializer</em>
nested within an <em>object initializer</em>. As an example, let&#39;s look at
how we might create a <code>BatchAnnotateImagesRequest</code> message in the
Vision API. (This is just an easy-to-understand example; the
Google.Cloud.Vision.V1 package provides helper methods to avoid you
having to create batches yourself in most cases.)</p>
<p>The protobuf description looks like this:</p>
<pre><code class="lang-proto">// Multiple image annotation requests are batched into a single service call.
message BatchAnnotateImagesRequest {
  // Individual image annotation requests for this batch.
  repeated AnnotateImageRequest requests = 1;
}
</code></pre><p>In the generated C# code, the <code>Requests</code> property of
<code>BatchAnnotateImagesRequest</code> is read-only, but you can populate it
with a collection initializer:</p>
<pre><code class="lang-cs">// In normal code you&#39;d populate these individual requests with more
// information.
AnnotateImageRequest request1 = new AnnotateImageRequest();
AnnotateImageRequest request2 = new AnnotateImageRequest();

// Create the batch request using an object initializer
BatchAnnotateImagesRequest batch = new BatchAnnotateImagesRequest
{
    // Populate the repeated field with a collection initializer
    Requests = { request1, request2 }
};
</code></pre><p>You don&#39;t <em>have</em> to use a collection initializer though, and
sometimes it would be inconvenient to do so. It&#39;s perfectly valid to
add to the repeated field after other initialization:</p>
<pre><code class="lang-cs">// In normal code you&#39;d populate these individual requests with more
// information.
AnnotateImageRequest request1 = new AnnotateImageRequest();
AnnotateImageRequest request2 = new AnnotateImageRequest();

// Populate the batch without using an object initializer, just by calling
// Add on the repeated field
BatchAnnotateImagesRequest batch = new BatchAnnotateImagesRequest();
batch.Requests.Add(request1);
batch.Requests.Add(request2);
</code></pre><p>Finally, it&#39;s worth being aware that <code>RepeatedField&lt;T&gt;</code> has an <code>Add</code>
overload accepting an <code>IEnumerable&lt;T&gt;</code>. This allows you to use a
collection initializer to copy items out of another collection, or a
LINQ query result:</p>
<pre><code class="lang-cs">// In normal code you&#39;d populate these individual requests with more
// information.
List&lt;AnnotateImageRequest&gt; requests = new List&lt;AnnotateImageRequest&gt;
{
    new AnnotateImageRequest(),
    new AnnotateImageRequest()
};

// Create the batch request using an object initializer
BatchAnnotateImagesRequest batch = new BatchAnnotateImagesRequest
{
    // Populate the repeated field using the Add overload that accepts
    // an IEnumerable&lt;T&gt;
    Requests = { requests }
};
</code></pre><p>Likewise for map fields (which are significantly less common) you
can use collection initializers, or (from C# 6 onwards) the indexer
syntax within an object initializer. As an example of this, let&#39;s
consider the Scheduler V1 API, which contains a message like this:</p>
<pre><code class="lang-proto">message HttpTarget {
  // Other fields omitted

  // The user can specify HTTP request headers to send with the job&#39;s
  // HTTP request. (Further documentation omitted here.)
  map&lt;string, string&gt; headers = 3;
}
</code></pre><p>Again, the <code>Headers</code> property in the generated message is read-only,
but you can populate it with a collection initializer:</p>
<pre><code class="lang-cs">HttpTarget target = new HttpTarget
{
    Headers =
    {
        {  &quot;X-Custom-Header1&quot;, &quot;Value1&quot; },
        {  &quot;X-Custom-Header2&quot;, &quot;Value2&quot; },
    }
};
</code></pre><p>Or an indexer in an object initializer:</p>
<pre><code class="lang-cs">HttpTarget target = new HttpTarget
{
    Headers =
    {
        [&quot;X-Custom-Header1&quot;] = &quot;Value1&quot;,
        [&quot;X-Custom-Header2&quot;] = &quot;Value2&quot;,
    }
};
</code></pre><p>Or modify it after other initialization steps:</p>
<pre><code class="lang-cs">HttpTarget target = new HttpTarget();
target.Headers[&quot;X-Custom-Header1&quot;] = &quot;Value1&quot;;
target.Headers[&quot;X-Custom-Header2&quot;] = &quot;Value2&quot;;
</code></pre><h2 id="why-is-systementrypointnotfoundexception-being-thrown">Why is System.EntryPointNotFoundException being thrown?</h2>
<p>While there are various <em>potential</em> causes for this, the most likely
(as of summer 2019) is that you have a dependency on Grpc.Core 2.x,
but our libraries still depend on Grpc.Core 1.x.</p>
<p>In August 2019, Grpc.Core 2.23.0 was released. The previous version
of Grpc.Core was 1.22.0, which is what the Google Cloud client
libraries depend on. As SemVer would suggest, versions 1.x and 2.x
of Grpc.Core are not compatible with each other. The incompatibility
is around how streaming operations are consumed, and is a side-effect
of C# 8 gaining the ability to iterate over asynchronous sequences.
Obviously a breaking change is never pleasant, but this was thoroughly
discussed, and this was the result.</p>
<p>While the Google Cloud client libraries depend on Grpc.Core 1.x, if
your project takes a dependency on Grpc.Core 2.x, you will see this
exception if you use streaming operations. (If you don&#39;t use any
streaming operations you <em>may</em> not see a problem, but we still
strongly discourage you from trying.)</p>
<p>Our plan to mitigate this issue is:</p>
<ul>
<li>Use version ranges for Grpc.Core so that the break is at build time
rather than execution time, until the next steps are ready. (Done)</li>
<li>Migrate to depend on Grpc.Core 2.x within the Google Cloud client
libraries.</li>
<li>Rerelease all libraries with a major version bump, as taking a major
dependency version bump is a transitive breaking change.</li>
<li>Update this FAQ entry to explain why the major bump occurred.</li>
</ul>
<p>We&#39;re collecting a few breaking changes to make, all at the same
time, so that we can get away with a single major version bump.</p>
<p>See <a href="major-version.html">the major version planning document</a> for more
details.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
             
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="styles/docfx.js"></script>
    <script type="text/javascript" src="styles/main.js"></script>
  </body>
</html>
