<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Google.Cloud.Spanner.Data | Google.Cloud.Spanner.Data </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Google.Cloud.Spanner.Data | Google.Cloud.Spanner.Data ">
    <meta name="generator" content="docfx 2.39.1.0">
    
    <link rel="shortcut icon" href="favicon.ico">
    <link rel="stylesheet" href="styles/docfx.vendor.css">
    <link rel="stylesheet" href="styles/docfx.css">
    <link rel="stylesheet" href="styles/main.css">
    <meta property="docfx:navrel" content="toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="index.html">
                <img id="logo" class="svg" src="logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="article row grid">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="googlecloudspannerdata">Google.Cloud.Spanner.Data</h1>

<p><code>Google.Cloud.Spanner.Data</code> is the ADO.NET provider for Cloud Spanner. It is the recommended
package for regular Cloud Spanner database access from .NET.</p>
<p>Note:
This documentation is for version <code>2.0.0</code> of the library.
Some samples may not work with other versions.</p>
<p>The <a href="../Google.Cloud.Spanner.Admin.Instance.V1/">Google.Cloud.Spanner.Admin.Instance.V1</a> package
should be used for Cloud Spanner instance administration, such as creating or deleting instances.</p>
<h1 id="installation">Installation</h1>
<p>Install the <code>Google.Cloud.Spanner.Data</code> package from NuGet. Add it to
your project in the normal way (for example by right-clicking on the
project in Visual Studio and choosing &quot;Manage NuGet Packages...&quot;).</p>
<h1 id="authentication">Authentication</h1>
<p>When running on Google Cloud Platform, no action needs to be taken to authenticate.</p>
<p>Otherwise, the simplest way of authenticating your API calls is to
download a service account JSON file then set the <code>GOOGLE_APPLICATION_CREDENTIALS</code> environment variable to refer to it.
The credentials will automatically be used to authenticate. See the <a href="https://cloud.google.com/docs/authentication/getting-started">Getting Started With
Authentication</a> guide for more details.</p>
<h1 id="getting-started">Getting started</h1>
<p>Operations generally follow ADO.NET conventions.
However Cloud Spanner does not support DML (eg. &quot;INSERT INTO ...&quot;). Therefore you should
use the corresponding API on SpannerConnection to create ADO command objects instead
of setting CommandText manually.</p>
<p>See examples below:</p>
<h1 id="sample-code">Sample code</h1>
<p>Once you have created your Google Cloud Project and Spanner Instance using the web console,
you can start using the ADO.NET provider to create and modify a Cloud Spanner database.</p>
<h2 id="creating-a-database-and-table">Creating a Database and Table</h2>
<pre><code class="lang-cs">using (SpannerConnection connection = new SpannerConnection(connectionString))
{
    SpannerCommand createDbCmd = connection.CreateDdlCommand($&quot;CREATE DATABASE {databaseName}&quot;);
    await createDbCmd.ExecuteNonQueryAsync();

    SpannerCommand createTableCmd = connection.CreateDdlCommand(
        @&quot;CREATE TABLE TestTable (
                                Key                STRING(MAX) NOT NULL,
                                StringValue        STRING(MAX),
                                Int64Value         INT64,
                              ) PRIMARY KEY (Key)&quot;);
    await createTableCmd.ExecuteNonQueryAsync();
}
</code></pre><h2 id="dataadapter-support-net-45-only">DataAdapter support (.NET 4.5+ only)</h2>
<p>Cloud Spanner supports a limited DataAdapter that provides basic CRUD operations on any table.
Create a SpannerDataAdapter with the target table and its primary keys.  You may replace any
commands provided by SpannerDataAdapter with your own custom commands.</p>
<pre><code class="lang-cs">using (SpannerConnection connection = new SpannerConnection(connectionString))
{
    DataSet untypedDataSet = new DataSet();

    // Provide the name of the Cloud Spanner table and primary key column names.
    SpannerDataAdapter adapter = new SpannerDataAdapter(connection, &quot;TestTable&quot;, &quot;Key&quot;);
    adapter.Fill(untypedDataSet);

    // Insert a row
    DataRow row = untypedDataSet.Tables[0].NewRow();
    row[&quot;Key&quot;] = Guid.NewGuid().ToString(&quot;N&quot;);
    row[&quot;StringValue&quot;] = &quot;New String Value&quot;;
    row[&quot;Int64Value&quot;] = 0L;
    untypedDataSet.Tables[0].Rows.Add(row);

    adapter.Update(untypedDataSet.Tables[0]);
}
</code></pre><h2 id="modifying-data">Modifying data</h2>
<p>Cloud Spanner supports two approaches to modifying data: DML, and direct row modifications.</p>
<h3 id="dml">DML</h3>
<p>DML is capable of affecting multiple rows with a single command. For example, you could delete all
rows matching a query, or update rows to set the value of one column equal to another one.</p>
<p>DML can be executed in standard mode using <code>ExecuteNonQuery</code> or <code>ExecuteNonQueryAsync</code>:</p>
<pre><code class="lang-cs">using (SpannerConnection connection = new SpannerConnection(connectionString))
{
    await connection.OpenAsync();

    SpannerCommand cmd = connection.CreateDmlCommand(
        &quot;UPDATE TestTable SET StringValue=&#39;Updated&#39; WHERE Int64Value=@value&quot;);
    cmd.Parameters.Add(&quot;value&quot;, SpannerDbType.Int64, 10);
    int rowsAffected = await cmd.ExecuteNonQueryAsync();
    Console.WriteLine($&quot;{rowsAffected} rows updated...&quot;);
}
</code></pre><p>If you execute DML within a transaction, queries are able to observe the changes already made by DML statements,
and later DML statements can use the values created or updated by earlier ones.</p>
<p>Some DML statements can be executed in a <em>partitioned</em> manner, enabling an efficient
update of large data sets. <code>ExecutePartitionedUpdate</code> or <code>ExecutePartitionedUpdateAsync</code>:</p>
<pre><code class="lang-cs">using (SpannerConnection connection = new SpannerConnection(connectionString))
{
    await connection.OpenAsync();

    SpannerCommand cmd = connection.CreateDmlCommand(
        &quot;UPDATE TestTable SET TestTable.StringValue=&#39;Updated in partitions&#39; WHERE TestTable.Int64Value=@value&quot;);
    cmd.Parameters.Add(&quot;value&quot;, SpannerDbType.Int64, 9);
    long rowsAffected = await cmd.ExecutePartitionedUpdateAsync();
    Console.WriteLine($&quot;{rowsAffected} rows updated...&quot;);
}
</code></pre><p>Partitioned DML updates cannot be performed within another transaction, and have &quot;at least once&quot; semantics:
the update can be applied more than once to a row in some cases, and so is best used with idempotent updates.</p>
<p>Not all DML statements can be partitioned. Please read the Cloud Spanner user documentation for details on
the restrictions.</p>
<h3 id="batch-dml">Batch DML</h3>
<p>Batch DML allows you to execute multiple DML commands in one batched operation.</p>
<pre><code class="lang-cs">using (SpannerConnection connection = new SpannerConnection(connectionString))
{
    await connection.OpenAsync();

    SpannerBatchCommand cmd = connection.CreateBatchDmlCommand();

    cmd.Add(
        &quot;UPDATE TestTable SET StringValue=&#39;Updated&#39; WHERE Int64Value=@value&quot;,
        new SpannerParameterCollection { { &quot;value&quot;, SpannerDbType.Int64, 5 } });

    cmd.Add(
        &quot;DELETE FROM TestTable WHERE Int64Value=@value&quot;,
        new SpannerParameterCollection { { &quot;value&quot;, SpannerDbType.Int64, 250 } });

    IEnumerable&lt;long&gt; rowsAffected = await cmd.ExecuteNonQueryAsync();
    Console.WriteLine($&quot;{rowsAffected.ElementAt(0)} rows updated...&quot;);
    Console.WriteLine($&quot;{rowsAffected.ElementAt(1)} rows deleted...&quot;);
}
</code></pre><p>Statements are executed sequentally in the same order they are provided. Changes made by one statement are
visible to all subsequent statements in the batch.</p>
<p>When one of the statemens in the batch fails, execution is halted and all subsequent statements are not
executed. A <code>SpannerBatchNonQueryException</code> will be thrown that contains both information about the error
and the number of rows affected by each of the statements that executed before the failed one. If you are executing
the batch DML command inside a transaction you can simply commit the transaction when <code>SpannerBatchNonQueryException</code>
is thrown if partial success is acceptable in your application.</p>
<h3 id="direct-row-modifications">Direct row modifications</h3>
<p>The following operations are supported for direct row modification:</p>
<ul>
<li>Insert</li>
<li>Update</li>
<li>Delete</li>
<li>Insert or update (also known as &quot;upsert&quot;)</li>
</ul>
<p>Create a command from the <code>SpannerConnection</code>, providing the table name to the appropriate method
(<code>CreateInsertCommand</code> and the like), then use the command parameters to specify values for columns.
The command can be reused to perform the same kind of operation for multiple rows.</p>
<p>This sample inserts two rows, then reads them again:</p>
<pre><code class="lang-cs">using (SpannerConnection connection = new SpannerConnection(connectionString))
{
    await connection.OpenAsync();

    SpannerCommand cmd = connection.CreateInsertCommand(&quot;TestTable&quot;);
    SpannerParameter keyParameter = cmd.Parameters.Add(&quot;Key&quot;, SpannerDbType.String);
    SpannerParameter stringValueParameter = cmd.Parameters.Add(&quot;StringValue&quot;, SpannerDbType.String);
    SpannerParameter int64ValueParameter = cmd.Parameters.Add(&quot;Int64Value&quot;, SpannerDbType.Int64);

    // This executes 5 distinct transactions with one row written per transaction.
    for (int i = 0; i &lt; 5; i++)
    {
        keyParameter.Value = Guid.NewGuid().ToString(&quot;N&quot;);
        stringValueParameter.Value = $&quot;StringValue{i}&quot;;
        int64ValueParameter.Value = i;
        int rowsAffected = await cmd.ExecuteNonQueryAsync();
        Console.WriteLine($&quot;{rowsAffected} rows written...&quot;);
    }
}
</code></pre><p>This sample reads three keys using a <code>SELECT</code> command, updates a row using an <code>UPDATE</code> command, then
deletes a row using a <code>DELETE</code> command:</p>
<pre><code class="lang-cs">using (SpannerConnection connection = new SpannerConnection(connectionString))
{
    await connection.OpenAsync();

    // Read the first two keys in the database.
    List&lt;string&gt; keys = new List&lt;string&gt;();
    SpannerCommand selectCmd = connection.CreateSelectCommand(&quot;SELECT * FROM TestTable&quot;);
    using (SpannerDataReader reader = await selectCmd.ExecuteReaderAsync())
    {
        while (keys.Count &lt; 3 &amp;&amp; await reader.ReadAsync())
        {
            keys.Add(reader.GetFieldValue&lt;string&gt;(&quot;Key&quot;));
        }
    }

    // Update the Int64Value of keys[0]
    // Include the primary key and update columns.
    SpannerCommand updateCmd = connection.CreateUpdateCommand(&quot;TestTable&quot;);
    updateCmd.Parameters.Add(&quot;Key&quot;, SpannerDbType.String, keys[0]);
    updateCmd.Parameters.Add(&quot;Int64Value&quot;, SpannerDbType.Int64, 0L);
    await updateCmd.ExecuteNonQueryAsync();

    // Delete row for keys[1]
    SpannerCommand deleteCmd = connection.CreateDeleteCommand(&quot;TestTable&quot;);
    deleteCmd.Parameters.Add(&quot;Key&quot;, SpannerDbType.String, keys[1]);
    await deleteCmd.ExecuteNonQueryAsync();
}
</code></pre><p>When direct row modifications are performed in a transaction, they are only applied when the transaction is committed.
Queries within the transaction will not observe any changes.</p>
<h3 id="using-a-commit-timestamp">Using a commit timestamp</h3>
<p>Spanner allows you to write a commit timestamp for insert and update
operations.</p>
<p>When using direct row modifications, the commit timestamp can be set
using <code>SpannerParameter.CommitTimestamp</code> as the value for a
parameter, as shown below.</p>
<pre><code class="lang-cs">using (SpannerConnection connection = new SpannerConnection(connectionString))
{
    await connection.OpenAsync();

    string createTableStatement =
        @&quot;CREATE TABLE UsersHistory (
        Id INT64 NOT NULL,
        CommitTs TIMESTAMP NOT NULL OPTIONS
            (allow_commit_timestamp=true),
        Name STRING(MAX) NOT NULL,
        Email STRING(MAX),
        Deleted BOOL NOT NULL,
      ) PRIMARY KEY(Id, CommitTs DESC)&quot;;

    await connection.CreateDdlCommand(createTableStatement).ExecuteNonQueryAsync();

    // Insert a first row
    SpannerCommand cmd = connection.CreateInsertCommand(&quot;UsersHistory&quot;,
        new SpannerParameterCollection
        {
            { &quot;Id&quot;, SpannerDbType.Int64, 10L },
            { &quot;CommitTs&quot;, SpannerDbType.Timestamp, SpannerParameter.CommitTimestamp },
            { &quot;Name&quot;, SpannerDbType.String, &quot;Demo 1&quot; },
            { &quot;Deleted&quot;, SpannerDbType.Bool, false }
        });
    int rowsAffected = await cmd.ExecuteNonQueryAsync();

    // Insert a second row
    cmd.Parameters[&quot;Id&quot;].Value = 11L;
    cmd.Parameters[&quot;Name&quot;].Value = &quot;Demo 2&quot;;
    rowsAffected += await cmd.ExecuteNonQueryAsync();
    Console.WriteLine($&quot;{rowsAffected} rows written...&quot;);

    // Display the inserted values
    SpannerCommand selectCmd = connection.CreateSelectCommand(&quot;SELECT * FROM UsersHistory&quot;);
    using (SpannerDataReader reader = await selectCmd.ExecuteReaderAsync())
    {
        while (await reader.ReadAsync())
        {
            long id = reader.GetFieldValue&lt;long&gt;(&quot;Id&quot;);
            string name = reader.GetFieldValue&lt;string&gt;(&quot;Name&quot;);
            DateTime timestamp = reader.GetFieldValue&lt;DateTime&gt;(&quot;CommitTs&quot;);
            Console.WriteLine($&quot;{id}: {name} - {timestamp:HH:mm:ss.ffffff}&quot;);
        }
    }
}
</code></pre><p>This parameter value cannot be used in DML. Instead, use the
<code>PENDING_COMMIT_TIMESTAMP()</code> function in your DML statement.</p>
<p>See the <a href="https://cloud.google.com/spanner/docs/commit-timestamp">Cloud Spanner
documentation</a>
for more information about commit timestamps.</p>
<h2 id="transactions-and-fault-handling">Transactions and Fault Handling</h2>
<p>Cloud Spanner is fully ACID compliant.</p>
<p>Retries should be implemented at the transaction level (as opposed to individual call level)
because there is a chance in high stress situations that a Cloud Spanner session (transaction)
can be canceled due to causing a deadlock. In this case, the entire transaction should be
retried and run on a new session.</p>
<p>Use the extension method IsTransientSpannerFault() on Exception to create your detection
strategy for the TransientFaultApplication Block.</p>
<pre><code class="lang-cs">private class SpannerFaultDetectionStrategy : ITransientErrorDetectionStrategy
{
    /// &lt;inheritdoc /&gt;
    public bool IsTransient(Exception ex) =&gt; ex.IsTransientSpannerFault();
}
</code></pre><p> You should execute the entire transaction within a RetryPolicy. Generally, we recommend
 using exponential backoff as shown below.</p>
<pre><code class="lang-cs">RetryPolicy&lt;SpannerFaultDetectionStrategy&gt; retryPolicy =
    new RetryPolicy&lt;SpannerFaultDetectionStrategy&gt;(RetryStrategy.DefaultExponential);

await retryPolicy.ExecuteAsync(
    async () =&gt;
    {
        using (SpannerConnection connection = new SpannerConnection(connectionString))
        {
            await connection.OpenAsync();

            using (SpannerTransaction transaction = await connection.BeginTransactionAsync())
            {
                SpannerCommand cmd = connection.CreateInsertCommand(
                    &quot;TestTable&quot;, new SpannerParameterCollection
                    {
                        {&quot;Key&quot;, SpannerDbType.String},
                        {&quot;StringValue&quot;, SpannerDbType.String},
                        {&quot;Int64Value&quot;, SpannerDbType.Int64}
                    });
                cmd.Transaction = transaction;

                // This executes a single transactions with alls row written at once during CommitAsync().
                // If a transient fault occurs, this entire method is re-run.
                for (int i = 0; i &lt; 5; i++)
                {
                    cmd.Parameters[&quot;Key&quot;].Value = Guid.NewGuid().ToString(&quot;N&quot;);
                    cmd.Parameters[&quot;StringValue&quot;].Value = $&quot;StringValue{i}&quot;;
                    cmd.Parameters[&quot;Int64Value&quot;].Value = i;
                    await cmd.ExecuteNonQueryAsync();
                }

                await transaction.CommitAsync();
            }
        }
    });
</code></pre><h2 id="transactionscope-support-net-45-single-resource-only">TransactionScope support (.NET 4.5+, Single resource only)</h2>
<p>In addition to supporting setting Transaction on individual commands, Spanner also supports
TransactionScope and implicit transactions given that only a single resource is involved.</p>
<p>Spanner does not support public two phase commit to commit multiple resources in a
single transaction.</p>
<pre><code class="lang-cs">RetryPolicy&lt;SpannerFaultDetectionStrategy&gt; retryPolicy =
    new RetryPolicy&lt;SpannerFaultDetectionStrategy&gt;(RetryStrategy.DefaultExponential);

await retryPolicy.ExecuteAsync(
    async () =&gt;
    {
        using (TransactionScope scope = new TransactionScope(TransactionScopeAsyncFlowOption.Enabled))
        {
            using (SpannerConnection connection = new SpannerConnection(connectionString))
            {
                await connection.OpenAsync();

                SpannerCommand cmd = connection.CreateInsertCommand(
                    &quot;TestTable&quot;, new SpannerParameterCollection
                    {
                        {&quot;Key&quot;, SpannerDbType.String},
                        {&quot;StringValue&quot;, SpannerDbType.String},
                        {&quot;Int64Value&quot;, SpannerDbType.Int64}
                    });

                // This executes a single transactions with alls row written at once during scope.Complete().
                // If a transient fault occurs, this entire method is re-run.
                for (int i = 0; i &lt; 5; i++)
                {
                    cmd.Parameters[&quot;Key&quot;].Value = Guid.NewGuid().ToString(&quot;N&quot;);
                    cmd.Parameters[&quot;StringValue&quot;].Value = $&quot;StringValue{i}&quot;;
                    cmd.Parameters[&quot;Int64Value&quot;].Value = i;
                    await cmd.ExecuteNonQueryAsync();
                }

                scope.Complete();
            }
        }
    });
</code></pre><h2 id="session-pool-management">Session pool management</h2>
<p><code>Google.Cloud.Spanner.Data</code> manages Spanner sessions for you via a
session pool. The pool has various <a href="configuration.html">configuration
options</a>, but additionally you may wish to take
advantage of additional <code>SpannerConnection</code> methods at the start and
end of your application.</p>
<p>To ensure that the session pool is populated with the configured
minimum number of sessions before serving requests from your
application, you may wish to wait for the task returned by
<code>SpannerConnection.WhenSessionPoolReady()</code> to complete before
marking your application as &quot;ready to serve&quot;.</p>
<pre><code class="lang-cs">// This would usually be executed during application start-up, before any Spanner
// operations are performed. It can be used at any time, however. It is purely passive:
// it doesn&#39;t modify the session pool or trigger any other actions.
using (SpannerConnection connection = new SpannerConnection(connectionString))
{
    await connection.WhenSessionPoolReady();
}
</code></pre><p>When your application is shutting down, you may wish to delete the
sessions it has been using from the server. Most applications will
not need to do this: sessions automatically expire after an idle
time of an hour anyway, and the server-enforced session limit is
high. Applications using a large number of sessions may wish to
clean up sessions more actively, however. Again, <code>SpannerConnection</code>
provides a simple method to accomplish this:</p>
<pre><code class="lang-cs">// When your application is shutting down. Note that any pending or future requests
// for sessions will fail.
using (SpannerConnection connection = new SpannerConnection(connectionString))
{
    await connection.ShutdownSessionPoolAsync();
}
</code></pre><p>If you want to diagnose session management issues,
<code>SpannerConnection</code> provides a method to fetch a snapshot of
the statistics for the session pool associated with the database
associated with the connection:</p>
<pre><code class="lang-cs">using (SpannerConnection connection = new SpannerConnection(connectionString))
{
    SessionPool.DatabaseStatistics stats = connection.GetSessionPoolDatabaseStatistics();
    if (stats is null)
    {
        Console.WriteLine(&quot;No session pool for this connection string yet&quot;);
    }
    else
    {
        // Access individual properties...
        Console.WriteLine($&quot;Database name: {stats.DatabaseName}&quot;);
        Console.WriteLine($&quot;Active sessions: {stats.ActiveSessionCount}&quot;);
        Console.WriteLine($&quot;Pooled read-only sessions: {stats.ReadPoolCount}&quot;);
        Console.WriteLine($&quot;Pooled read-write sessions: {stats.ReadWritePoolCount}&quot;);
        // ... or just use the overridden ToString method to log all the statistics in one go:
        Console.WriteLine(stats);
    }
}
</code></pre></article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
             
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="styles/docfx.js"></script>
    <script type="text/javascript" src="styles/main.js"></script>
  </body>
</html>
