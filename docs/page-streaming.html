<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Page streaming | Google Cloud APIs </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Page streaming | Google Cloud APIs ">
    <meta name="generator" content="docfx 2.16.0.499">
    
    <link rel="shortcut icon" href="favicon.ico">
    <link rel="stylesheet" href="styles/docfx.vendor.css">
    <link rel="stylesheet" href="styles/docfx.css">
    <link rel="stylesheet" href="styles/main.css">
    <meta property="docfx:navrel" content="toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="index.html">
                <img id="logo" class="svg" src="logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="article row grid">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
              <h1 id="page-streaming">Page streaming</h1>
              
<h2 id="introduction">Introduction</h2>
<p>Many Google APIs expose operations to list resources, possibly
filtering them. Often, there may be many, many matching resources,
so the results are returned one &quot;page&quot; at a time. Each request can
specify a <em>page token</em> which identifies the start of the page of
results to return, and each response specifies a <em>next page token</em>
to use in the subsequent request. If the end of the logical result
list has been reached, the next page token is not specified.</p>
<p>In addition to the resources in the page, a list response can
include extra information such as the total size of the list,
or perhaps the cost of performing the query.</p>
<p>The code required to iterate over all the results in a list is not
difficult, but it is tedious and error-prone, so the C# client
libraries have abstracted this away.</p>
<p>Operations listing resources synchronously return a
<a href="api/Google.Api.Gax.PagedEnumerable-2.html">PagedEnumerable&lt;TResponse, TResource&gt;</a>, and operations listing
resources asynchronously return a
<a href="api/Google.Api.Gax.PagedAsyncEnumerable-2.html">PagedAsyncEnumerable&lt;TResponse, TResource&gt;</a>.
These are equivalent other than their asynchrony, so
this document focuses on the synchronous version for simplicity.</p>
<h2 id="pagedenumerabletresponse-tresource"><code>PagedEnumerable&lt;TResponse, TResource&gt;</code></h2>
<p>Let&#39;s look at the generic type parameters first. The <code>TResponse</code> is
the API response type for the list operation, and the <code>TResource</code> is
the type of the resource being listed. In the Pub/Sub API for
example, the <code>ListTopics</code> operation accepts a <code>ListTopicsRequest</code>
and returns a <code>ListTopicsResponse</code> containing a set of <code>Topic</code>
resources - so the <a href="Google.Pubsub.V1/api/Google.Pubsub.V1.PublisherClient.html#Google_Pubsub_V1_PublisherClient_ListTopics_Google_Cloud_PubSub_V1_ProjectName_String_System_Nullable_System_Int32__Google_Api_Gax_CallSettings_">PublisherClient.ListTopics</a>
method returns a <code>PagedEnumerable&lt;ListTopicsResponse, Topic&gt;</code>.</p>
<p><code>PagedEnumerable&lt;TResponse, TResource&gt;</code> implements
<code>IEnumerable&lt;TResource&gt;</code>.  If you simply iterate over it, you will
retrieve one resource at a time. The implementation will make API
calls as it needs to, retrieving a page at a time and then returning
the resources as the caller requests them.</p>
<h2 id="asrawresponses"><code>AsRawResponses</code></h2>
<p>For more advanced scenarios, however, your application may need access
to the raw responses returned by the API instead. The
<a href="api/Google.Api.Gax.PagedEnumerable-2.html#Google_Api_Gax_PagedEnumerable_2_AsRawResponses">PagedEnumerable&lt;TResponse, TResource&gt;.AsRawResponses()</a>
method returns an <code>IEnumerable&lt;TResponse&gt;</code>, so you can iterate over the responses easily. Each
response provides access to the individual resources within the page, and some APIs may
provide additional information such as the time taken for the request or the total number of
results across all pages. As you iterate over the pages, API requests are made
transparently, propagating the page token from one response to the next request.</p>
<h2 id="readpage"><code>ReadPage</code></h2>
<p><code>PagedEnumerable&lt;TResponse, TResource&gt;</code> also has a 
<a href="api/Google.Api.Gax.PagedEnumerable-2.html#Google_Api_Gax_PagedEnumerable_2_ReadPage_System_Int32_">ReadPage(int)</a>
method to cater for web applications which require precise page sizes.</p>
<p>Although APIs generally allow the application to specify the page size to return, this
is an upper limit rather than a hard requirement. It&#39;s possible for an API to return fewer results,
even if more are available - for example, if the server notices that it is close to reaching the specified
RPC deadline. While that&#39;s fine for many batch scenarios, it isn&#39;t ideal if the results are being presented to users,
where typically you want to provide the exact same number of results per page.</p>
<p>The <code>ReadPage</code> method makes multiple API requests if necessary, in order to &quot;fill&quot; a page (of a specified size)
until it reaches the end of the resources being listed. The return value is a
<a href="api/Google.Api.Gax.Page-1.html#Google_Api_Gax_Page_1">Page&lt;TResource&gt;</a> which provides the items
within each page, along with the page token used to retrieve the next page. (This would typically be used in a &quot;next page&quot; link
in the web results.)</p>
<h2 id="use-case-sample-code">Use case sample code</h2>
<h3 id="iterate-over-all-resources-ignoring-pagination">Iterate over all resources, ignoring pagination</h3>
<pre><code class="lang-cs">PublisherClient client = PublisherClient.Create();
ProjectName projectName = new ProjectName(projectId);
PagedEnumerable&lt;ListTopicsResponse, Topic&gt; topics = client.ListTopics(projectName, pageSize: 3);
foreach (Topic topic in topics)
{
    Console.WriteLine(topic.Name);
}
</code></pre><h3 id="iterate-over-all-responses-remembering-page-tokens">Iterate over all responses, remembering page tokens</h3>
<pre><code class="lang-cs">PublisherClient client = PublisherClient.Create();
ProjectName projectName = new ProjectName(projectId);
PagedEnumerable&lt;ListTopicsResponse, Topic&gt; topics = client.ListTopics(projectName, pageSize: 3);
IEnumerable&lt;ListTopicsResponse&gt; topicResponses = topics.AsRawResponses();
foreach (ListTopicsResponse response in topicResponses)
{
    Console.WriteLine(&quot;Topics in response:&quot;);
    foreach (Topic topic in response.Topics)
    {
        Console.WriteLine($&quot;  {topic.Name}&quot;);
    }
    // If you were processing items in batches, you might wish to store this
    // in order to recover from failures. The page token can be passed into the ListTopics method.
    Console.WriteLine($&quot;Next page token: {response.NextPageToken}&quot;);
}
</code></pre><h3 id="obtain-a-single-natural-page-of-results">Obtain a single &quot;natural&quot; page of results</h3>
<pre><code class="lang-cs">PublisherClient client = PublisherClient.Create();
ProjectName projectName = new ProjectName(projectId);
PagedEnumerable&lt;ListTopicsResponse, Topic&gt; topics = client.ListTopics(projectName, pageSize: 3);
IEnumerable&lt;ListTopicsResponse&gt; topicResponses = topics.AsRawResponses();
// This is just the regular LINQ First() method. The sequence of pages will never be empty,
// but the page may have no resources.
ListTopicsResponse firstResponse = topicResponses.First();
Console.WriteLine(&quot;Topics in response:&quot;);
foreach (Topic topic in firstResponse.Topics)
{
    Console.WriteLine($&quot;  {topic.Name}&quot;);
}
// If you were processing items in batches, you might wish to store this
// in order to recover from failures. The page token can be passed into the ListTopics method.
Console.WriteLine($&quot;Next page token: {firstResponse.NextPageToken}&quot;);
</code></pre><h3 id="display-the-next-fixed-sized-page-of-results">Display the next fixed-sized page of results</h3>
<p>This is typically used in web applications; it will only display a less-than-full
page if it reaches the end of the data.</p>
<pre><code class="lang-cs">PublisherClient client = PublisherClient.Create();
ProjectName projectName = new ProjectName(projectId);
PagedEnumerable&lt;ListTopicsResponse, Topic&gt; topics = client.ListTopics(projectName, pageTokenFromRequest);

Page&lt;Topic&gt; page = topics.ReadPage(3);
// In a web application, this would be a matter of including the topics in the web page.
foreach (Topic topic in page)
{
    Console.WriteLine(topic.Name);
}
// ... and embedding the next page token into a &quot;next page&quot; link.
Console.WriteLine($&quot;Next page token: {page.NextPageToken}&quot;);
</code></pre><h2 id="feedback">Feedback</h2>
<p>What other use cases should we consider? Does this meet your current needs?
Please <a href="https://github.com/GoogleCloudPlatform/google-cloud-dotnet/issues/new">raise an issue on github</a>
to provide feedback.</p>

            </article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
             
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="styles/docfx.js"></script>
    <script type="text/javascript" src="styles/main.js"></script>
  </body>
</html>
