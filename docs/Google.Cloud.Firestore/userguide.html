<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>User guide | Google.Cloud.Firestore </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="User guide | Google.Cloud.Firestore ">
    <meta name="generator" content="docfx 2.39.1.0">
    
    <link rel="shortcut icon" href="favicon.ico">
    <link rel="stylesheet" href="styles/docfx.vendor.css">
    <link rel="stylesheet" href="styles/docfx.css">
    <link rel="stylesheet" href="styles/main.css">
    <meta property="docfx:navrel" content="toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="index.html">
                <img id="logo" class="svg" src="logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="article row grid">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="user-guide">User guide</h1>

<h2 id="accessing-documents-and-collections">Accessing documents and collections</h2>
<p>From <code>FirestoreDb</code>, you can create a <code>DocumentReference</code> or <code>CollectionReference</code> directly by
their path from the database root. From a <code>DocumentReference</code> you can create a <code>CollectionReference</code>
for a child collection, and likewise from a <code>CollectionReference</code> you can create a <code>DocumentReference</code>
for a child document.</p>
<pre><code class="lang-cs">FirestoreDb db = FirestoreDb.Create(projectId);

// You can create references directly from FirestoreDb:
CollectionReference citiesFromDb = db.Collection(&quot;cities&quot;);
DocumentReference londonFromDb = db.Document(&quot;cities/london&quot;);
CollectionReference londonRestaurantsFromDb = db.Collection(&quot;cities/london/restaurants&quot;);

// Or from other references:
DocumentReference londonFromCities = citiesFromDb.Document(&quot;london&quot;);
CollectionReference londonRestaurantFromLondon = londonFromDb.Collection(&quot;restaurants&quot;);
</code></pre><h2 id="writing-documents">Writing documents</h2>
<p>See the <a href="datamodel.html">data model</a> page for the different representations available. For the rest of
this section, we will use the following attributed class:</p>
<pre><code class="lang-cs">[FirestoreData]
public class City
{
    [FirestoreProperty]
    public string Name { get; set; }

    [FirestoreProperty]
    public string State { get; set; }

    [FirestoreProperty]
    public string Country { get; set; }

    [FirestoreProperty(&quot;Capital&quot;)]
    public bool IsCapital { get; set; }

    [FirestoreProperty]
    public long Population { get; set; }
}
</code></pre><h3 id="creating-a-document">Creating a document</h3>
<p>A specific document can be created using <code>DocumentReference.CreateAsync</code>; alternatively,
<code>CollectionReference.AddAsync</code> will generate a random document ID within the associated collection.</p>
<pre><code class="lang-cs">FirestoreDb db = FirestoreDb.Create(projectId);

// Create a document with a random ID in the &quot;cities&quot; collection.
CollectionReference collection = db.Collection(&quot;cities&quot;);
City city = new City
{
    Name = &quot;Los Angeles&quot;,
    Country = &quot;USA&quot;,
    State = &quot;CA&quot;,
    IsCapital = false,
    Population = 3900000L
};

// Alternatively, collection.Document(&quot;los-angeles&quot;).Create(city);
DocumentReference document = await collection.AddAsync(city);
</code></pre><p>Once created, a document can be modified in multiple ways.</p>
<h3 id="updating-specific-fields">Updating specific fields</h3>
<p>Specific fields in the document can be modified using <code>DocumentReference.UpdateAsync</code>. Currently this
requires a <code>Dictionary&lt;FieldMask, object&gt;</code> to be passed in, but we intend to improve this experience.
See <a href="furtherwork.html">further work items</a> for more discussion over improving this.</p>
<p>A precondition may be specified for the update.</p>
<pre><code class="lang-cs">Dictionary&lt;FieldPath, object&gt; updates = new Dictionary&lt;FieldPath, object&gt;
{
    { new FieldPath(&quot;Population&quot;), 3900005L },
    { new FieldPath(&quot;Country&quot;), &quot;United States of America&quot; }
};
await document.UpdateAsync(updates);
</code></pre><h3 id="setting-document-data-with-optional-merging">Setting document data with optional merging</h3>
<p>The <code>SetAsync</code> operation is versatile. By default it replaces all data in the document. For example, this code:</p>
<pre><code class="lang-cs">City newCity = new City
{
    Name = &quot;Los Angeles&quot;,
    Country = &quot;United States of America&quot;,
    Population = 3900005L
};
await document.SetAsync(newCity);
</code></pre><p>... would end up wiping out setting the <code>State</code> field in the document to a null value. (<code>Capital</code> would still be <code>false</code>,
as that&#39;s the default value of the <code>bool</code> type.)</p>
<p>To use our class model but specify which fields we want to merge, we can specify an appropriate <code>SetOptions</code>.</p>
<pre><code class="lang-cs">City newCity = new City
{
    Name = &quot;Los Angeles&quot;,
    Country = &quot;United States of America&quot;,
    Population = 3900005L
};
await document.SetAsync(newCity, SetOptions.MergeFields(&quot;Country&quot;, &quot;Population&quot;));
</code></pre><p>A simpler option in many cases - particularly when your document doesn&#39;t deal with nested data - is to use an anonymous
type to specify the fields you want to modify, and specify <code>SetOptions.MergeAll</code> so that all the fields you&#39;ve specified
in the anonymous type are merged, but no others.</p>
<pre><code class="lang-cs">await document.SetAsync(
    new { Country = &quot;United States of America&quot;, Population = 3900005L },
    SetOptions.MergeAll);
</code></pre><h3 id="deleting-a-document">Deleting a document</h3>
<p>Deleting a document is simple via <code>DocumentReference.DeleteAsync</code>. A precondition can be specified (for example, to only
delete the document if its last-update timestamp matches one you know); otherwise the delete operation is unconditional.</p>
<pre><code class="lang-cs">await document.DeleteAsync();
// With no precondition, the delete call succeeds even if the document
// doesn&#39;t exist. With a precondition of &quot;document must exist&quot; the call
// will fail if the document doesn&#39;t exist.
await document.DeleteAsync();
</code></pre><p>All of these operations can also be performed in batches via <code>WriteBatch</code>, or within transactions.</p>
<h2 id="reading-documents">Reading documents</h2>
<p>Once your data is in Firestore, you probably want to read it at some point.</p>
<h3 id="fetching-a-document-snapshot">Fetching a document snapshot</h3>
<p><code>DocumentReference</code> allows you to fetch a snapshot of a document:</p>
<pre><code class="lang-cs">DocumentSnapshot snapshot = await document.GetSnapshotAsync();
// Even if there&#39;s no document in the server, we still get a snapshot
// back - but it knows the document doesn&#39;t exist.
Console.WriteLine(snapshot.Exists);

// Individual fields can be checked and fetched
Console.WriteLine(snapshot.ContainsField(&quot;Planet&quot;)); // False
Console.WriteLine(snapshot.GetValue&lt;string&gt;(&quot;Name&quot;)); // Los Angeles

// Or you can deserialize to a dictionary or a model
City fetchedCity = snapshot.ConvertTo&lt;City&gt;();
Console.WriteLine(fetchedCity.Name); // Los Angeles
</code></pre><h3 id="querying">Querying</h3>
<p>You can also query collections, either directly to retrieve all the data from all the documents in the collection,
or with filtering, projections, ordering etc.</p>
<pre><code class="lang-cs">FirestoreDb db = FirestoreDb.Create(projectId);
CollectionReference collection = db.Collection(&quot;cities&quot;);

// A CollectionReference is a Query, so we can just fetch everything
QuerySnapshot allCities = await collection.GetSnapshotAsync();
foreach (DocumentSnapshot document in allCities.Documents)
{
    // Do anything you&#39;d normally do with a DocumentSnapshot
    City city = document.ConvertTo&lt;City&gt;();
    Console.WriteLine(city.Name);
}

// But we can apply filters, perform ordering etc too.
Query bigCitiesQuery = collection
    .WhereGreaterThan(&quot;Population&quot;, 3000000)
    .OrderByDescending(&quot;Population&quot;);

QuerySnapshot bigCities = await bigCitiesQuery.GetSnapshotAsync();
foreach (DocumentSnapshot document in bigCities.Documents)
{
    // Do anything you&#39;d normally do with a DocumentSnapshot
    City city = document.ConvertTo&lt;City&gt;();
    Console.WriteLine($&quot;{city.Name}: {city.Population}&quot;);
}
</code></pre><h2 id="transactions">Transactions</h2>
<p>Transactions accept a callback of user code, which is then passed a <code>Transaction</code> object
to work with.</p>
<p>The callback can return optionally a value.</p>
<p>The callback will be executed multiple times if the transaction needs to be retried due to conflicting
modifications.</p>
<p>In this section, we&#39;ll deal with a simple document that just has a single counter. We want to keep an up-to-date counter,
and periodically (once per day, for example) we&#39;ll update another counter to match the current value. For more
details of counters, see the <a href="https://firebase.google.com/docs/firestore/solutions/counters">main Firestore user guide</a>.</p>
<h3 id="updating-the-daily-counter-from-the-current-one">Updating the daily counter from the current one</h3>
<p>Once a day, we want to atomically fetch the current counter, and update the daily one.</p>
<pre><code class="lang-cs">FirestoreDb db = FirestoreDb.Create(projectId);
CollectionReference collection = db.Collection(&quot;counters&quot;);
DocumentReference currentCounter = collection.Document(&quot;current&quot;);
DocumentReference dailyCounter = collection.Document(&quot;daily&quot;);

await db.RunTransactionAsync(async transaction =&gt;
{
    DocumentSnapshot currentSnapshot = await transaction.GetSnapshotAsync(currentCounter);
    long counter = currentSnapshot.GetValue&lt;long&gt;(&quot;Counter&quot;);
    transaction.Set(dailyCounter, new { Counter = counter });
});
</code></pre><h3 id="updating-the-current-counter">Updating the current counter</h3>
<p>When we update the current counter, we may well want to know the current value afterwards. That&#39;s easily done by
returning it from the callback:</p>
<pre><code class="lang-cs">FirestoreDb db = FirestoreDb.Create(projectId);
CollectionReference collection = db.Collection(&quot;counters&quot;);
DocumentReference currentCounter = collection.Document(&quot;current&quot;);

long newValue = await db.RunTransactionAsync(async transaction =&gt;
{
    DocumentSnapshot currentSnapshot = await transaction.GetSnapshotAsync(currentCounter);
    long counter = currentSnapshot.GetValue&lt;long&gt;(&quot;Counter&quot;) + 1;
    transaction.Set(currentCounter, new { Counter = counter });
    return counter;
});
// Use the value we&#39;ve just written in application code
Console.WriteLine(newValue);
</code></pre><h2 id="listening-for-changes">Listening for changes</h2>
<p>Firestore allows you to listen for changes to either a single
document or the results of a query. You provide a callback which is
executed each time a change occurs.</p>
<p>First we&#39;ll see an example of each, then go into details.</p>
<h3 id="listening-for-changes-on-a-document">Listening for changes on a document</h3>
<p>This example starts listening for changes on a document that doesn&#39;t
exist yet, then creates the document, updates it, deletes it, and recreates it.
Each of these changes is logged by the callback.
After stopping the listening operation, the document is updated one
final time - which doesn&#39;t produce any output.</p>
<pre><code class="lang-cs">FirestoreDb db = FirestoreDb.Create(projectId);
// Create a random document ID. The document doesn&#39;t exist yet.
DocumentReference doc = db.Collection(collectionId).Document();            

FirestoreChangeListener listener = doc.Listen(snapshot =&gt;
{
    Console.WriteLine($&quot;Callback received document snapshot&quot;);
    Console.WriteLine($&quot;Document exists? {snapshot.Exists}&quot;);
    if (snapshot.Exists)
    {
        Console.WriteLine($&quot;Value of &#39;value&#39; field: {snapshot.GetValue&lt;int?&gt;(&quot;value&quot;)}&quot;);
    }
    Console.WriteLine();
});

Console.WriteLine(&quot;Creating document&quot;);
await doc.CreateAsync(new { value = 10 });
await Task.Delay(1000);

Console.WriteLine($&quot;Updating document&quot;);
await doc.SetAsync(new { value = 20 });
await Task.Delay(1000);

Console.WriteLine($&quot;Deleting document&quot;);
await doc.DeleteAsync();
await Task.Delay(1000);

Console.WriteLine(&quot;Creating document again&quot;);
await doc.CreateAsync(new { value = 30 });
await Task.Delay(1000);

Console.WriteLine(&quot;Stopping the listener&quot;);
await listener.StopAsync();

Console.WriteLine($&quot;Updating document (no output expected)&quot;);
await doc.SetAsync(new { value = 40 });
await Task.Delay(1000);
</code></pre><h3 id="listening-for-changes-in-a-query">Listening for changes in a query</h3>
<p>This example listens for changes in a query of &quot;documents with a
score greater than 5, in descending score order&quot;. Each document has
two fields: &quot;Name&quot; and &quot;Score&quot;.</p>
<p>When the listener is set up, the test makes the following data changes:</p>
<ul>
<li>Add a document for Sophie, with score 7</li>
<li>Add a document for James, with score 10</li>
<li>Update the score for Sophie to 11 (changing its order within the query)</li>
<li>Update the score for Sophie to 12 (no change in order, but the document is updated)</li>
<li>Update the score for James to 4 (no longer matches the query)</li>
<li>Delete the document for Sophie</li>
</ul>
<pre><code class="lang-cs">FirestoreDb db = FirestoreDb.Create(projectId);
CollectionReference collection = db.Collection(collectionId);
Query query = collection.WhereGreaterThan(&quot;Score&quot;, 5).OrderByDescending(&quot;Score&quot;);

FirestoreChangeListener listener = query.Listen(snapshot =&gt;
{
    Console.WriteLine($&quot;Callback received query snapshot&quot;);
    Console.WriteLine($&quot;Count: {snapshot.Count}&quot;);
    Console.WriteLine(&quot;Changes:&quot;);
    foreach (DocumentChange change in snapshot.Changes)
    {
        DocumentSnapshot document = change.Document;
        Console.WriteLine($&quot;{document.Reference.Id}: ChangeType={change.ChangeType}; OldIndex={change.OldIndex}; NewIndex={change.NewIndex})&quot;);
        if (document.Exists)
        {
            string name = document.GetValue&lt;string&gt;(&quot;Name&quot;);
            int score = document.GetValue&lt;int&gt;(&quot;Score&quot;);
            Console.WriteLine($&quot;  Document data: Name={name}; Score={score}&quot;);
        }
    }
    Console.WriteLine();
});

Console.WriteLine(&quot;Creating document for Sophie (Score = 7)&quot;);
DocumentReference doc1Ref = await collection.AddAsync(new { Name = &quot;Sophie&quot;, Score = 7 });
Console.WriteLine($&quot;Sophie document ID: {doc1Ref.Id}&quot;);
await Task.Delay(1000);

Console.WriteLine(&quot;Creating document for James (Score = 10)&quot;);
DocumentReference doc2Ref = await collection.AddAsync(new { Name = &quot;James&quot;, Score = 10 });
Console.WriteLine($&quot;James document ID: {doc2Ref.Id}&quot;);
await Task.Delay(1000);

Console.WriteLine(&quot;Modifying document for Sophie (set Score = 11, higher than score for James)&quot;);
await doc1Ref.UpdateAsync(&quot;Score&quot;, 11);
await Task.Delay(1000);

Console.WriteLine(&quot;Modifying document for Sophie (set Score = 12, no change in position)&quot;);
await doc1Ref.UpdateAsync(&quot;Score&quot;, 12);
await Task.Delay(1000);

Console.WriteLine(&quot;Modifying document for James (set Score = 4, below threshold for query)&quot;);
await doc2Ref.UpdateAsync(&quot;Score&quot;, 4);
await Task.Delay(1000);

Console.WriteLine(&quot;Deleting document for Sophie&quot;);
await doc1Ref.DeleteAsync();
await Task.Delay(1000);

Console.WriteLine(&quot;Stopping listener&quot;);
await listener.StopAsync();
</code></pre><h3 id="listener-threading">Listener threading</h3>
<p>Each listener you start runs independently. It effectively loops
through three steps:</p>
<ul>
<li>Wait for the server to provide changes</li>
<li>Update its internal model</li>
<li>Report any changes via the callback</li>
</ul>
<p>The listener waits for the callback to complete before continuing.
The callbacks can be provided as either a synchronous action or an
asynchronous function that returns a task. For asynchronous
callbacks, the listener waits for the returned task to complete.
This allows you to use async/await within a callback without
worrying about the callback executing multiple times concurrently
for a single listener.</p>
<p>Each listener acts independently without any synchronization, so if
you use the same callback for multiple listeners, the callback could
be called multiple times concurrently, one for each listener.</p>
<p>Although each listener &quot;logically&quot; operates in a single-threaded
fashion, it uses asynchronous operations and so the actual thread
used can change between callbacks. We strongly recommend against
using thread-local storage; ideally, make no assumptions about the
thread that will run your callback.</p>
<h3 id="stopping-listeners">Stopping listeners</h3>
<p>When you start listening for changes, the method returns a
<code>FirestoreChangeListener</code>. This has two important members:</p>
<ul>
<li>The <code>ListenerTask</code> property returns a task representing the
ongoing listen operation.</li>
<li>The <code>StopAsync</code> method allows you to stop the listener. For
convenience, this returns the same task as <code>ListenerTask</code>.</li>
</ul>
<p>The <code>StopAsync</code> method will allow any currently executing callback
to complete before the listener shuts down. However, both the
original <code>Listen</code> calls and the <code>StopAsync</code> methods accept an optional
<code>CancellationToken</code>. If this cancellation token is cancelled, not
only will the listener stop, but the cancellation token passed to
any asynchronous callback will also be cancelled. This allows you to
perform asynchronous operations within the callback but still be
able to cancel the whole listener quickly.</p>
<p>In the &quot;graceful&quot; shutdown case, nothing is cancelled: you call
<code>StopAsync</code>, any current callback completes, and then the listener
task completes. If this is all you need, you never need to provide a
cancellation token to the methods to start or stop listening.
The cancellation token functionality has been provided for two
specific scenarios:</p>
<ul>
<li><p>The listen operation is being executed as part of another
cancellable operation. In this case you&#39;d provide the cancellation
token when you start listening.</p>
</li>
<li><p>The listen operation is long-running, but you need to shut it down
as part of shutting down some larger system (such as a web
server). Typically this shutdown procedure provides a cancellation
token: if the graceful shutdown doesn&#39;t complete within a certain
time, the cancellation token is cancelled. The signature of
<code>StopAsync</code> allows you to integrate Firestore into this pattern
easily.</p>
</li>
</ul>
<p>The final status of the listener task will be:</p>
<ul>
<li><code>RanToCompletion</code> if shutdown completed gracefully.</li>
<li><code>Faulted</code> if either the listener encountered a permanent error, or
the callback threw an exception.</li>
<li><code>Canceled</code> if shutdown was either caused by the &quot;start&quot; cancellation
token being canceled, or if the &quot;stop&quot; cancellation token was
canceled.</li>
</ul>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
             
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="styles/docfx.js"></script>
    <script type="text/javascript" src="styles/main.js"></script>
  </body>
</html>
