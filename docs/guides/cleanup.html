<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Unmanaged resource clean-up | Google Cloud APIs </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Unmanaged resource clean-up | Google Cloud APIs ">
    <meta name="generator" content="docfx 2.24.0.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="unmanaged-resource-clean-up">Unmanaged resource clean-up</h1>

<h2 id="grpc-based-apis-and-channels">gRPC-based APIs and channels</h2>
<p>gRPC uses the concept of a <em>channel</em> between your application
and the service implementing an API. This consists of a network
connection and some unmanaged resources which handle its status and
multiplex the requests and responses on it.</p>
<p>Most of the time, you don&#39;t need to worry about cleaning up the
unmanaged resources from the C# client libraries.</p>
<p>If you want to handle this explicitly, you can do so by creating
channels yourself and shutting them down in an orderly fashion. For
slightly less control (but a simpler life) you can let the client
libraries create channels themselves as necessary, and shut them
down explicitly using the static <code>ShutDownDefaultChannelsAsync</code>
method which each client class exposes. (For example,
<a href="../Google.Cloud.PubSub.V1/api/Google.Cloud.PubSub.V1.PublisherClient.html#Google_Cloud_PubSub_V1_PublisherClient_ShutDownDefaultChannelsAsync">PublisherClient.ShutDownDefaultChannelsAsync()</a> and
<a href="../Google.Cloud.PubSub.V1/api/Google.Cloud.PubSub.V1.SubscriberClient.html#Google_Cloud_PubSub_V1_SubscriberClient_ShutDownDefaultChannelsAsync">SubscriberClient.ShutDownDefaultChannelsAsync()</a>.)</p>
<p>Finally, gRPC provides an environment-wide shutdown method of <code>GrpcEnvironment.ShutdownChannelsAsync()</code>.</p>
<p>In all of these cases, it&#39;s entirely feasible to create more channels (implicitly or explicitly)
after shutting others down... it will just require a new network connection to be opened.</p>
<p>If you do not shut down the channels explicitly, they will be closed automatically
when either the application domain is unloaded, or the process exits. For most applications, this is
perfectly adequate; explicit shutdown is only required when your application needs to ensure that
it has handled all requests appropriately before exiting.</p>
<h2 id="rest-based-apis">REST-based APIs</h2>
<p>Summary: Use a single client if you can; if you have to create
multiple clients at a high frequency, dispose of them when you&#39;re
done.</p>
<p>Just as a reminder, Google Cloud Client Libraries for .NET has three
libraries for REST-based APIs:</p>
<ul>
<li>Google.Cloud.Storage.V1 (StorageClient)</li>
<li>Google.Cloud.BigQuery.V2 (BigQueryClient)</li>
<li>Google.Cloud.Translation.V2 (TranslationClient, AdvancedTranslationClient)</li>
</ul>
<p>In November 2017, these client classes were changed to implement the
<code>IDisposable</code> interface. The <code>Dispose</code> method simply disposes of the
underlying service object, which in turn disposes of the underlying
<code>HttpClient</code>.</p>
<p>There are three broad usage scenarios to consider:</p>
<ul>
<li>A single long-lived client object (or perhaps a limited set,
e.g. using different credentials) used for many operations.</li>
<li>A new client used for each set of operations, e.g. a new client
created for each incoming request on a web site, but with relatively
low-frequency use.</li>
<li>A new client created for each set of operations, with high-frequency
use.</li>
</ul>
<p>The ability to dispose of the client really only affects the last of
these scenarios. The way that <code>HttpClient</code> works has two downsides
when new clients are created frequently:</p>
<ul>
<li>Connections to the API server (e.g. the Storage API server) can
take a long time to close. This can cause problems if you&#39;re running
in an environment with a limited number of available connections.</li>
<li>Buffers within <code>HttpClient</code> can consume memory for longer than is
desirable.</li>
</ul>
<p>In many cases these don&#39;t actually cause problems - if you don&#39;t
reach your connection limit, and the garbage collector is collecting
the <code>HttpClient</code> buffers fast enough to keep your memory usage low,
you&#39;re fine. Likewise if you only ever create a limited set of
client objects, you shouldn&#39;t run into issues.</p>
<p>In other cases, where (for whatever reason) you really want to
create a lot of client objects in quick succession, it&#39;s prudent to
dispose of the clients when you&#39;re done with them. Now that the
client classes implement <code>IDisposable</code>, you can simply use <code>using</code>
statements in the normal way.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
             
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
