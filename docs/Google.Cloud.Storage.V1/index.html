<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Google.Cloud.Storage.V1 | Google.Cloud.Storage.V1 </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Google.Cloud.Storage.V1 | Google.Cloud.Storage.V1 ">
    <meta name="generator" content="docfx 2.16.0.499">
    
    <link rel="shortcut icon" href="favicon.ico">
    <link rel="stylesheet" href="styles/docfx.vendor.css">
    <link rel="stylesheet" href="styles/docfx.css">
    <link rel="stylesheet" href="styles/main.css">
    <meta property="docfx:navrel" content="toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="index.html">
                <img id="logo" class="svg" src="logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="article row grid">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
              <h1 id="googlecloudstoragev1">Google.Cloud.Storage.V1</h1>
              
<p><code>Google.Cloud.Storage.V1</code> is a .NET client library for <a href="https://cloud.google.com/storage/">Google
Cloud Storage</a>. It wraps the
<code>Google.Apis.Storage.v1</code> generated library, providing a
higher-level API to make it easier to use.</p>
<h1 id="installation">Installation</h1>
<p>Install the <code>Google.Cloud.Storage.V1</code> package from NuGet. Add it to
your project in the normal way (for example by right-clicking on the
project in Visual Studio and choosing &quot;Manage NuGet Packages...&quot;).</p>
<h1 id="authentication">Authentication</h1>
<p>To authenticate all your API calls, first install and setup the
<a href="https://cloud.google.com/sdk/">Google Cloud SDK</a>. After that is
installed, run the following command in a Google Cloud SDK Shell:</p>
<pre><code class="lang-sh">&gt; gcloud auth application-default login
</code></pre><h1 id="getting-started">Getting started</h1>
<p>Common operations are exposed via the
<a href="api/Google.Cloud.Storage.V1.StorageClient.html">StorageClient</a> class.</p>
<h1 id="sample-code">Sample code</h1>
<pre><code class="lang-cs">var client = StorageClient.Create();

// Create a bucket
var bucketName = Guid.NewGuid().ToString(); // must be globally unique
var bucket = client.CreateBucket(projectId, bucketName);

// Upload some files
var content = Encoding.UTF8.GetBytes(&quot;hello, world&quot;);
var obj1 = client.UploadObject(bucketName, &quot;file1.txt&quot;, &quot;text/plain&quot;, new MemoryStream(content));
var obj2 = client.UploadObject(bucketName, &quot;folder1/file2.txt&quot;, &quot;text/plain&quot;, new MemoryStream(content));

// List objects
foreach (var obj in client.ListObjects(bucketName, &quot;&quot;))
{
    Console.WriteLine(obj.Name);
}

// Download file
using (var stream = File.OpenWrite(&quot;file1.txt&quot;))
{
    client.DownloadObject(bucketName, &quot;file1.txt&quot;, stream);
}
</code></pre><h2 id="signed-urls">Signed URLs</h2>
<p>Signed URLs can be created to provide limited access to specific buckets and
objects to anyone in possession of the URL, regardless of whether they have
a Google account.</p>
<p>For example, Signed URLs can be created to provide read-only access to
existing objects:</p>
<pre><code class="lang-cs">// Create a signed URL which can be used to get a specific object for one hour.
UrlSigner urlSigner = UrlSigner.FromServiceAccountCredential(credential);
string url = urlSigner.Sign(
    bucketName,
    objectName,
    TimeSpan.FromHours(1),
    HttpMethod.Get);

// Get the content at the created URL.
HttpResponseMessage response = await httpClient.GetAsync(url);
string content = await response.Content.ReadAsStringAsync();
</code></pre><p>Or write-only access to put specific object content into a bucket:</p>
<pre><code class="lang-cs">// Create a signed URL which allows the requester to PUT data with the text/plain content-type.
UrlSigner urlSigner = UrlSigner.FromServiceAccountCredential(credential);
var destination = &quot;places/world.txt&quot;;
string url = urlSigner.Sign(
    bucketName,
    destination,
    TimeSpan.FromHours(1),
    HttpMethod.Put,
    contentHeaders: new Dictionary&lt;string, IEnumerable&lt;string&gt;&gt; {
        { &quot;Content-Type&quot;, new[] { &quot;text/plain&quot; } }
    });

// Upload the content into the bucket using the signed URL.
string source = &quot;world.txt&quot;;

ByteArrayContent content;
using (FileStream stream = File.OpenRead(source))
{
    byte[] data = new byte[stream.Length];
    stream.Read(data, 0, data.Length);
    content = new ByteArrayContent(data)
    {
        Headers = { ContentType = new MediaTypeHeaderValue(&quot;text/plain&quot;) }
    };
}

HttpResponseMessage response = await httpClient.PutAsync(url, content);
</code></pre><h2 id="upload-uris">Upload URIs</h2>
<p>In some cases, it may not make sense for client applications to have permissions
to begin an upload for an object, but an authenticated service may choose to grant
this ability for individual uploads. Signed URLs are one option for this. Another
option is for the service to start a resumable upload session, but instead of
performing the upload, sending the resulting upload URI to the client application
so it can perform the upload instead. Unlike sessions initiated with a signed URL,
a pre-initated upload session will force the client application to upload through
the region in which the session began, which will likely be close to the service,
and not necessarily the client.</p>
<pre><code class="lang-cs">var client = StorageClient.Create();
var source = &quot;world.txt&quot;;
var destination = &quot;places/world.txt&quot;;
var contentType = &quot;text/plain&quot;;

// var acl = PredefinedAcl.PublicRead // public
var acl = PredefinedObjectAcl.AuthenticatedRead; // private
var options = new UploadObjectOptions { PredefinedAcl = acl };
// Create a temporary uploader so the upload session can be manually initiated without actually uploading.
var tempUploader = client.CreateObjectUploader(bucketName, destination, contentType, new MemoryStream(), options);
var uploadUri = await tempUploader.InitiateSessionAsync();

// Send uploadUri to (unauthenticated) client application, so it can perform the upload:
using (var stream = File.OpenRead(source))
{
    // IUploadProgress defined in Google.Apis.Upload namespace
    IProgress&lt;IUploadProgress&gt; progress = new Progress&lt;IUploadProgress&gt;(
      p =&gt; Console.WriteLine($&quot;bytes: {p.BytesSent}, status: {p.Status}&quot;)
    );

    var actualUploader = ResumableUpload.CreateFromUploadUri(uploadUri, stream);
    actualUploader.ProgressChanged += progress.Report;
    await actualUploader.UploadAsync();
}
</code></pre><h2 id="customer-supplied-encryption-keys">Customer-supplied encryption keys</h2>
<p>Storage objects are always stored encrypted, but if you wish to
specify your own encryption key instead of using the server-supplied
one, you can do so either for all operations with a particular
<code>StorageClient</code> or on individual ones.</p>
<pre><code class="lang-cs">// Use EncryptionKey.Create if you already have a key.
EncryptionKey key = EncryptionKey.Generate();

// This will affect all relevant object-based operations by default.
var client = StorageClient.Create(encryptionKey: key);
var content = Encoding.UTF8.GetBytes(&quot;hello, world&quot;);
client.UploadObject(bucketName, &quot;encrypted.txt&quot;, &quot;text/plain&quot;, new MemoryStream(content));

// When downloading, either use a client with the same key...
client.DownloadObject(bucketName, &quot;encrypted.txt&quot;, new MemoryStream());

// Or specify a key just for that operation.
var client2 = StorageClient.Create();
client2.DownloadObject(bucketName, &quot;encrypted.txt&quot;, new MemoryStream(),
    new DownloadObjectOptions { EncryptionKey = key });
</code></pre>
            </article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
             
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="styles/docfx.js"></script>
    <script type="text/javascript" src="styles/main.js"></script>
  </body>
</html>
